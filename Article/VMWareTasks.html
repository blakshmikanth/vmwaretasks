<!--------------------------------------------------------------------------->
<!--                           INTRODUCTION                                

 The Code Project article submission template (HTML version)

Using this template will help us post your article sooner. To use, just 
follow the 3 easy steps below:
 
     1. Fill in the article description details
     2. Add links to your images and downloads
     3. Include the main article text

That's all there is to it! All formatting will be done by our submission
scripts and style sheets. 

-->
<!--------------------------------------------------------------------------->
<!--                        IGNORE THIS SECTION                            -->
<html>
<head>
 <title>The Code Project</title>
 <style>
BODY, P, TD { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt }
H2,H3,H4,H5 { color: #ff9900; font-weight: bold; }
H2 { font-size: 13pt; }
H3 { font-size: 12pt; }
H4 { font-size: 10pt; color: black; }
PRE { BACKGROUND-COLOR: #FBEDBB; FONT-FAMILY: "Courier New", Courier, mono; WHITE-SPACE: pre; }
CODE { COLOR: #990000; FONT-FAMILY: "Courier New", Courier, mono; }
</style>
 <link rel="stylesheet" type="text/css" href="http://www.codeproject.com/styles/global.css">
</head>
<body bgcolor="#FFFFFF" color="#000000">
 <!--------------------------------------------------------------------------->
 <!-------------------------------     STEP 1      --------------------------->
 <!--  Fill in the details (CodeProject will reformat this section for you) -->
 <pre lang="cs">Title:       Automating VMWare Tasks in C# with VIX API
Author:      Daniel Doubrovkine
Email:       dblock@dblock.org
Member ID:   913212
Language:    C#
Platform:    Windows, VMWare
Technology:  C#, COM
Level:       Intermediate
Description: A VMWare tasks library and primer
Section      Suggest a section...
SubSection   Suggest a subsection...
License:     <a href="http://www.codeproject.com/info/licenses.aspx">CPOL</a>
</pre>
 <ul class="download">
  <li><a href="Vestris.VMWareTasks.zip">Download binaries &amp; source - 25 Kb</a></li>
 </ul>
 <p>
  <img src="VMWareLogo.jpg" alt="VMWare" width="160" height="63"></p>
 <!-------------------------------     STEP 3      --------------------------->
 <!--  Add the article text. Please use simple formatting (<h2>, <p> etc)   -->
 <h2>
  Introduction
 </h2>
 <p>
  I've been playing with <a href="http://www.vmware.com/">VMware</a> lately, both
  Workstation and VMware Infrastructure (VI). The company has really stepped up with
  the new SDKs and the level of programmable interfaces, making some excellent implementation
  decisions that enable developers to drive virtual machines programmatically with
  an asynchronous, job-based programming model. Unfortunately that turns out to be
  too complicated for 99.9% of scenarios and most people want to have a simple object-oriented
  interface for common VMWare tasks. This article implements that interface.
 </p>
 <h2>
  Background
 </h2>
 <p>
  There're two types of VMWare APIs.
  <ul>
   <li>VMWare Virtual Infrastructure SDK: a set of tools and APIs to manage a VMWare
    Infrastructure environment. A toolkit has also been released that contains managed
    wrappers on top of the SOAP interface provided by a VMWare deployment. It's focused
    on VMWare ESX or VirtualCenter management and is beyond the scope of this post.
   </li>
   <li>VMWare VIX API. The VIX API allows you to write programs and scripts that automate
    virtual machine operations, as well as the guests within virtual machines. It runs
    on both Windows and Linux and supports management of VMware Server, Workstation,
    and Virtual Infrastructure (both ESX and vCenter). Bindings are provided for C,
    Perl, and COM (Visual Basic, VBscript, C#). In this post I'll focus on the C# implementation.
   </li>
  </ul>
  In order to build and run the source code in this article you need the following
  VMWare software.
  <ul>
   <li>VMWare ViX. This is the SDK, obtained from <a href="http://www.vmware.com/download/sdk/vmauto.html">
    http://www.vmware.com/download/sdk/vmauto.html</a>. The new 1.6.2 version is required
    for VI support.</li>
   <li>Either VMWare Workstation 6.5, a VI environment (I use ESX), or both.</li>
  </ul>
 </p>
 <h2>
  Implementation
 </h2>
 <h3>
  Connecting to VMWare in pure VIX API
 </h3>
 <p>
  Connecting synchronously to either a local VMWare Workstation or an ESX server is
  virtually identical. The ESX server requires an URL to the SOAP SDK (eg. https://esxserver/sdk)
  and a username and password.
  <pre lang="cs">public IHost ConnectToVMWareWorkstation()
{
    return Connect(Constants.VIX_SERVICEPROVIDER_VMWARE_WORKSTATION, string.Empty, 0, string.Empty, string.Empty);
}

public IHost ConnectToVMWareVIServer(string hostName, int hostPort, string username, string password)
{
    return Connect(Constants.VIX_SERVICEPROVIDER_VMWARE_VI_SERVER,  hostName, hostPort, username, password);
}

public IHost Connect(int hostType, string hostName, int hostPort, string username, string password)
{
    VixLib vix = new VixLib();
    IJob vmJob = vix.Connect(Constants.VIX_API_VERSION, hostType, hostName, hostPort, username, password, 0, null, null);
    // You need to get the IHost object that represents the host where your VM is located. 
    // Since COM allocates the object you need to use this funky mechanism to extract the IHosts array.
    object[] properties = { Constants.VIX_PROPERTY_JOB_RESULT_HANDLE };
    // Wait for the operation to complete
    object hosts = VmwareVixInterop.Wait(vmJob, properties);
    object[] hostArray = hosts as object[];
    return (IHost) hostArray[0];
}
  </pre>
 </p>
 <p>
  You need to declare an array of properties that you want the job to produce, start
  a VMWare job and examine the results for the host handle. You can see how cumbersome
  this is. The API was originally designed for C, then extended to COM with a very
  limited object model: a number of interfaces were declared, but no corresponding
  COM classes have been implemented. Also, because the job interface is generic, there're
  no strongly typed results. We can easily fill this gap in our C# implementation.
 </p>
 <h3>
  Transforming Error Codes into Exceptions
 </h3>
 <p>
  The first task for wrapping any API is to implement error handling. Our managed
  implementation must translate error codes into managed exceptions. VIX API provides
  an implementation for the IVixLib interface which contains a couple of helper methods
  (very C-programmer). We'll be interested in <code>IVixLib.ErrorIndicatesFailure</code>
  and <code>IVixLib.GetErrorText</code> combined with a new class, <code>VMWareException</code>.
  <pre lang="cs">
public abstract class VMWareInterop
{
    public static VixLib Instance = new VixLib();

    public static void Check(ulong errCode)
    {
        if (Instance.ErrorIndicatesFailure(errCode))
        {
            throw new VMWareException(errCode);
        }
    }
}
  </pre>
  Aside from the abstract <code>VMWareInterop</code> our goal is to produce concrete
  classes that wrap various aspects of VMWare functionality.
 </p>
 <h3>
  Base VMWareVixHandle
 </h3>
 <p>
  VMWare COM API returns interface pointers such as <span style="color: #990000; font-family: Courier New">
   ISnapshot</span>. The objects also implement <span style="color: #990000; font-family: Courier New">
    IVixHandle</span> which gives access to a set of object properties. We will baseclass
  everything on <span style="color: #990000; font-family: Courier New">VMWareVixHandle</span>.
  <pre lang="cs">
public class VMWareVixHandle&lt;T&gt;
{
    protected T _handle = default(T);
    
    protected IVixHandle _vixhandle
    {
        get
        {
            return (IVixHandle) _handle;
        }
    }

    public VMWareVixHandle()
    {

    }

    public VMWareVixHandle(T handle)
    {
        _handle = handle;
    }
    
    public object[] GetProperties(object[] properties)
    {
        object result = null;
        VMWareInterop.Check(_vixhandle.GetProperties(properties, ref result));
        return (object[]) result;
    }

    public R GetProperty&lt;R&gt;(int propertyId)
    {
        object[] properties = { propertyId };
        return (R) GetProperties(properties)[0];
    }
}
  </pre>
 </p>
 <h3>
  Implementing VMWareJob
 </h3>
 <p>
  Since all operations in VMWare are job-based, let's wrap up a job. If we use the
  COM API directly we would have to call <code>IVixLib.Wait</code> passing a job handle.
  In an object-oriented library this operation belongs inside the job, plus a job
  is also a a <code>VMWareVixHandle</code>.
 </p>
 <pre lang="cs"> public class VMWareJob : VMWareVixHandle&lt;IJob&gt;
 {
     public VMWareJob(IJob job)
         : base(job)
     {
     
     }

     public void Wait()
     {
         VMWareInterop.Check(_handle.WaitWithoutResults());
     }
 }
  </pre>
 <p>
  One very common mistake in VMWare API implementations that transform a asynchronous
  job into a synchronous one is to use the blocking wait above. This is a poor design
  decision since this call may never return. VMWare server may timeout or someone
  can pull the network cable, leaving your program hanging. An active timeout can
  easily solve the problem and all externally visible waits are going to be based
  on this <code>InternalWait</code>.
 </p>
 <pre lang="cs">private void InternalWait(int timeoutInSeconds)
{
    if (timeoutInSeconds == 0)
    {
        throw new ArgumentOutOfRangeException("timeoutInSeconds");
    }

    // active wait for the job to finish
    bool isComplete = false;
    while (!isComplete && timeoutInSeconds > 0)
    {
        VMWareInterop.Check(_handle.CheckCompletion(out isComplete));
        if (isComplete) break;
        Thread.Sleep(1000);
        timeoutInSeconds--;
    }

    if (timeoutInSeconds == 0)
    {
        throw new TimeoutException();
    }
}
  </pre>
 <h3>
  VMWareVirtualHost
 </h3>
 <p>
  With <code>VMWareJob</code> and <code>VMWareException</code> it's now possible to
  implement <code>VMWareVirtualHost</code> and connect to it. Note references to default
  timeouts (a collection of constants) and some facilities in <code>VMWareJob</code>
  that add strong typing into VMWare job results.
 </p>
 <pre lang="cs">public class VMWareVirtualHost
{
    private IHost _host = null;

    public VMWareVirtualHost()
    {

    }

    public void ConnectToVMWareWorkstation()
    {
        ConnectToVMWareWorkstation(VMWareInterop.Timeouts.ConnectTimeout);
    }

    public void ConnectToVMWareWorkstation(int timeoutInSeconds)
    {
        Connect(Constants.VIX_SERVICEPROVIDER_VMWARE_WORKSTATION,
            string.Empty, 0, string.Empty, string.Empty, timeoutInSeconds);
    }

    private void Connect(int hostType, string hostName, int hostPort, string username, string password, int timeout)
    {
        VMWareJob job = new VMWareJob(VMWareInterop._vix.Connect(
            Constants.VIX_API_VERSION,
            hostType, hostName, hostPort,
            username, password, 0, null, null)
            );
        object[] resultProperties = { Constants.VIX_PROPERTY_JOB_RESULT_HANDLE };
        _host = job.Wait&lt;IHost&gt;(resultProperties, 0, timeout);
    }
}        
  </pre>
 <p>
  <code>VMWareVirtualHost</code> can now implement opening of an actual virtual machine
  and return an instance of <code>VMWareVirtualMachine</code>.
 </p>
 <pre lang="cs">public VMWareVirtualMachine Open(string fileName, int timeoutInSeconds)
{
    VMWareJob job = new VMWareJob(_host.OpenVM(fileName, null));
    object[] resultProperties = { Constants.VIX_PROPERTY_JOB_RESULT_HANDLE };
    return new VMWareVirtualMachine(job.Wait&lt;IVM&gt;(resultProperties, 0, timeoutInSeconds));
}
  </pre>
 <p>
  Based on this model we can code many functions of <code>VMWareVirtualMachine</code>,
  <code>VMWareSnapshot</code>, etc. The rest is implementation details.
 </p>
 <p>
  <img src="VMWareClasses.jpg">
 </p>
 <h2>
  Implementation Details
 </h2>
 <h3>
  Dates and Times
 </h3>
 <p>
  Date/time in VMWare VIX is expressed in UNIX EPOCH (number of seconds since January
  1st, 1970).
  <pre lang="cs">DateTime currentDateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds((int) dt);</pre>
 </p>
 <h2>
  Using VMWareLib
 </h2>
 <p>
  The library exposes a very simple object model, easy to use. The following example
  powers on the current snapshot of a virtual machine and executes a remote command.
 </p>
 <pre lang="cs">VMWareVirtualHost virtualHost = new VMWareVirtualHost();
// connect to a local VM
virtualHost.ConnectToVMWareWorkstation();
VMWareVirtualMachine virtualMachine = virtualHost.Open(@"c:\vm\vm.vmx");
// power-on current snapshot
virtualMachine.PowerOn();
virtualMachine.Login("Administrator", "password");
virtualMachine.RunProgramInGuest("notepad.exe", string.Empty);
  </pre>
 <h2>
  Source Code and Patches
 </h2>
 <p>
  The latest version of this article and source code can always be found in <a href="http://subversion.tigris.org/">
   Subversion</a> under <a href="svn://svn.vestris.com/codeproject/VMWareTasks/">svn://svn.vestris.com/codeproject/VMWareTasks</a>.
  You can also <a href="http://svn.vestris.com/listing.php?repname=Vestris+SVN&path=%2Fcodeproject%2FVMWareTasks%2FSource%2F#_codeproject_VMWareTasks_Source_">
   browse the source code</a>. You can find the latest information about this library
  at <a href="http://code.dblock.org">code.dblock.org</a>. You're encouraged to sumit
  patches for added functionality and bug fixes, please direct everything to dblock
  at dblock dot org.
 </p>
 <h2>
  History
 </h2>
 <p>
 </p>
 <li>12/22/2008: initial version
  <h2>
   License
  </h2>
  <p>
   This library, along with any associated source code and files, is published under
   the <a href="http://www.codeproject.com/info/licenses.aspx">CPOL</a> license, please
   reuse.
  </p>
  <!-------------------------------    That's it!   --------------------------->
 </li>
 </p>
</body>
</html>
